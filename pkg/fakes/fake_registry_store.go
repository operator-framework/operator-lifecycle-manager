// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"sync"

	"github.com/operator-framework/operator-registry/pkg/api"
	"github.com/operator-framework/operator-registry/pkg/registry"
)

type FakeQuery struct {
	GetApisForEntryStub        func(context.Context, int64) ([]*api.GroupVersionKind, []*api.GroupVersionKind, error)
	getApisForEntryMutex       sync.RWMutex
	getApisForEntryArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	getApisForEntryReturns struct {
		result1 []*api.GroupVersionKind
		result2 []*api.GroupVersionKind
		result3 error
	}
	getApisForEntryReturnsOnCall map[int]struct {
		result1 []*api.GroupVersionKind
		result2 []*api.GroupVersionKind
		result3 error
	}
	GetBundleStub        func(context.Context, string, string, string) (*api.Bundle, error)
	getBundleMutex       sync.RWMutex
	getBundleArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getBundleReturns struct {
		result1 *api.Bundle
		result2 error
	}
	getBundleReturnsOnCall map[int]struct {
		result1 *api.Bundle
		result2 error
	}
	GetBundleForChannelStub        func(context.Context, string, string) (*api.Bundle, error)
	getBundleForChannelMutex       sync.RWMutex
	getBundleForChannelArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getBundleForChannelReturns struct {
		result1 *api.Bundle
		result2 error
	}
	getBundleForChannelReturnsOnCall map[int]struct {
		result1 *api.Bundle
		result2 error
	}
	GetBundlePathIfExistsStub        func(context.Context, string) (string, error)
	getBundlePathIfExistsMutex       sync.RWMutex
	getBundlePathIfExistsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getBundlePathIfExistsReturns struct {
		result1 string
		result2 error
	}
	getBundlePathIfExistsReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetBundlePathsForPackageStub        func(context.Context, string) ([]string, error)
	getBundlePathsForPackageMutex       sync.RWMutex
	getBundlePathsForPackageArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getBundlePathsForPackageReturns struct {
		result1 []string
		result2 error
	}
	getBundlePathsForPackageReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GetBundleThatProvidesStub        func(context.Context, string, string, string) (*api.Bundle, error)
	getBundleThatProvidesMutex       sync.RWMutex
	getBundleThatProvidesArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getBundleThatProvidesReturns struct {
		result1 *api.Bundle
		result2 error
	}
	getBundleThatProvidesReturnsOnCall map[int]struct {
		result1 *api.Bundle
		result2 error
	}
	GetBundleThatReplacesStub        func(context.Context, string, string, string) (*api.Bundle, error)
	getBundleThatReplacesMutex       sync.RWMutex
	getBundleThatReplacesArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getBundleThatReplacesReturns struct {
		result1 *api.Bundle
		result2 error
	}
	getBundleThatReplacesReturnsOnCall map[int]struct {
		result1 *api.Bundle
		result2 error
	}
	GetBundleVersionStub        func(context.Context, string) (string, error)
	getBundleVersionMutex       sync.RWMutex
	getBundleVersionArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getBundleVersionReturns struct {
		result1 string
		result2 error
	}
	getBundleVersionReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetBundlesForPackageStub        func(context.Context, string) (map[registry.BundleKey]struct{}, error)
	getBundlesForPackageMutex       sync.RWMutex
	getBundlesForPackageArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getBundlesForPackageReturns struct {
		result1 map[registry.BundleKey]struct{}
		result2 error
	}
	getBundlesForPackageReturnsOnCall map[int]struct {
		result1 map[registry.BundleKey]struct{}
		result2 error
	}
	GetChannelEntriesFromPackageStub        func(context.Context, string) ([]registry.ChannelEntryAnnotated, error)
	getChannelEntriesFromPackageMutex       sync.RWMutex
	getChannelEntriesFromPackageArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getChannelEntriesFromPackageReturns struct {
		result1 []registry.ChannelEntryAnnotated
		result2 error
	}
	getChannelEntriesFromPackageReturnsOnCall map[int]struct {
		result1 []registry.ChannelEntryAnnotated
		result2 error
	}
	GetChannelEntriesThatProvideStub        func(context.Context, string, string, string) ([]*registry.ChannelEntry, error)
	getChannelEntriesThatProvideMutex       sync.RWMutex
	getChannelEntriesThatProvideArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getChannelEntriesThatProvideReturns struct {
		result1 []*registry.ChannelEntry
		result2 error
	}
	getChannelEntriesThatProvideReturnsOnCall map[int]struct {
		result1 []*registry.ChannelEntry
		result2 error
	}
	GetChannelEntriesThatReplaceStub        func(context.Context, string) ([]*registry.ChannelEntry, error)
	getChannelEntriesThatReplaceMutex       sync.RWMutex
	getChannelEntriesThatReplaceArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getChannelEntriesThatReplaceReturns struct {
		result1 []*registry.ChannelEntry
		result2 error
	}
	getChannelEntriesThatReplaceReturnsOnCall map[int]struct {
		result1 []*registry.ChannelEntry
		result2 error
	}
	GetCurrentCSVNameForChannelStub        func(context.Context, string, string) (string, error)
	getCurrentCSVNameForChannelMutex       sync.RWMutex
	getCurrentCSVNameForChannelArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getCurrentCSVNameForChannelReturns struct {
		result1 string
		result2 error
	}
	getCurrentCSVNameForChannelReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetDefaultChannelForPackageStub        func(context.Context, string) (string, error)
	getDefaultChannelForPackageMutex       sync.RWMutex
	getDefaultChannelForPackageArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getDefaultChannelForPackageReturns struct {
		result1 string
		result2 error
	}
	getDefaultChannelForPackageReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetDefaultPackageStub        func(context.Context, string) (string, error)
	getDefaultPackageMutex       sync.RWMutex
	getDefaultPackageArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getDefaultPackageReturns struct {
		result1 string
		result2 error
	}
	getDefaultPackageReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetDependenciesForBundleStub        func(context.Context, string, string, string) ([]*api.Dependency, error)
	getDependenciesForBundleMutex       sync.RWMutex
	getDependenciesForBundleArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getDependenciesForBundleReturns struct {
		result1 []*api.Dependency
		result2 error
	}
	getDependenciesForBundleReturnsOnCall map[int]struct {
		result1 []*api.Dependency
		result2 error
	}
	GetImagesForBundleStub        func(context.Context, string) ([]string, error)
	getImagesForBundleMutex       sync.RWMutex
	getImagesForBundleArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getImagesForBundleReturns struct {
		result1 []string
		result2 error
	}
	getImagesForBundleReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GetLatestChannelEntriesThatProvideStub        func(context.Context, string, string, string) ([]*registry.ChannelEntry, error)
	getLatestChannelEntriesThatProvideMutex       sync.RWMutex
	getLatestChannelEntriesThatProvideArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getLatestChannelEntriesThatProvideReturns struct {
		result1 []*registry.ChannelEntry
		result2 error
	}
	getLatestChannelEntriesThatProvideReturnsOnCall map[int]struct {
		result1 []*registry.ChannelEntry
		result2 error
	}
	GetPackageStub        func(context.Context, string) (*registry.PackageManifest, error)
	getPackageMutex       sync.RWMutex
	getPackageArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getPackageReturns struct {
		result1 *registry.PackageManifest
		result2 error
	}
	getPackageReturnsOnCall map[int]struct {
		result1 *registry.PackageManifest
		result2 error
	}
	ListBundlesStub        func(context.Context) ([]*api.Bundle, error)
	listBundlesMutex       sync.RWMutex
	listBundlesArgsForCall []struct {
		arg1 context.Context
	}
	listBundlesReturns struct {
		result1 []*api.Bundle
		result2 error
	}
	listBundlesReturnsOnCall map[int]struct {
		result1 []*api.Bundle
		result2 error
	}
	ListChannelsStub        func(context.Context, string) ([]string, error)
	listChannelsMutex       sync.RWMutex
	listChannelsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	listChannelsReturns struct {
		result1 []string
		result2 error
	}
	listChannelsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	ListImagesStub        func(context.Context) ([]string, error)
	listImagesMutex       sync.RWMutex
	listImagesArgsForCall []struct {
		arg1 context.Context
	}
	listImagesReturns struct {
		result1 []string
		result2 error
	}
	listImagesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	ListPackagesStub        func(context.Context) ([]string, error)
	listPackagesMutex       sync.RWMutex
	listPackagesArgsForCall []struct {
		arg1 context.Context
	}
	listPackagesReturns struct {
		result1 []string
		result2 error
	}
	listPackagesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	ListRegistryBundlesStub        func(context.Context) ([]*registry.Bundle, error)
	listRegistryBundlesMutex       sync.RWMutex
	listRegistryBundlesArgsForCall []struct {
		arg1 context.Context
	}
	listRegistryBundlesReturns struct {
		result1 []*registry.Bundle
		result2 error
	}
	listRegistryBundlesReturnsOnCall map[int]struct {
		result1 []*registry.Bundle
		result2 error
	}
	ListTablesStub        func(context.Context) ([]string, error)
	listTablesMutex       sync.RWMutex
	listTablesArgsForCall []struct {
		arg1 context.Context
	}
	listTablesReturns struct {
		result1 []string
		result2 error
	}
	listTablesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	SendBundlesStub        func(context.Context, registry.BundleSender) error
	sendBundlesMutex       sync.RWMutex
	sendBundlesArgsForCall []struct {
		arg1 context.Context
		arg2 registry.BundleSender
	}
	sendBundlesReturns struct {
		result1 error
	}
	sendBundlesReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeQuery) GetApisForEntry(arg1 context.Context, arg2 int64) ([]*api.GroupVersionKind, []*api.GroupVersionKind, error) {
	fake.getApisForEntryMutex.Lock()
	ret, specificReturn := fake.getApisForEntryReturnsOnCall[len(fake.getApisForEntryArgsForCall)]
	fake.getApisForEntryArgsForCall = append(fake.getApisForEntryArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	fake.recordInvocation("GetApisForEntry", []interface{}{arg1, arg2})
	fake.getApisForEntryMutex.Unlock()
	if fake.GetApisForEntryStub != nil {
		return fake.GetApisForEntryStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.getApisForEntryReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQuery) GetApisForEntryCallCount() int {
	fake.getApisForEntryMutex.RLock()
	defer fake.getApisForEntryMutex.RUnlock()
	return len(fake.getApisForEntryArgsForCall)
}

func (fake *FakeQuery) GetApisForEntryCalls(stub func(context.Context, int64) ([]*api.GroupVersionKind, []*api.GroupVersionKind, error)) {
	fake.getApisForEntryMutex.Lock()
	defer fake.getApisForEntryMutex.Unlock()
	fake.GetApisForEntryStub = stub
}

func (fake *FakeQuery) GetApisForEntryArgsForCall(i int) (context.Context, int64) {
	fake.getApisForEntryMutex.RLock()
	defer fake.getApisForEntryMutex.RUnlock()
	argsForCall := fake.getApisForEntryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuery) GetApisForEntryReturns(result1 []*api.GroupVersionKind, result2 []*api.GroupVersionKind, result3 error) {
	fake.getApisForEntryMutex.Lock()
	defer fake.getApisForEntryMutex.Unlock()
	fake.GetApisForEntryStub = nil
	fake.getApisForEntryReturns = struct {
		result1 []*api.GroupVersionKind
		result2 []*api.GroupVersionKind
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQuery) GetApisForEntryReturnsOnCall(i int, result1 []*api.GroupVersionKind, result2 []*api.GroupVersionKind, result3 error) {
	fake.getApisForEntryMutex.Lock()
	defer fake.getApisForEntryMutex.Unlock()
	fake.GetApisForEntryStub = nil
	if fake.getApisForEntryReturnsOnCall == nil {
		fake.getApisForEntryReturnsOnCall = make(map[int]struct {
			result1 []*api.GroupVersionKind
			result2 []*api.GroupVersionKind
			result3 error
		})
	}
	fake.getApisForEntryReturnsOnCall[i] = struct {
		result1 []*api.GroupVersionKind
		result2 []*api.GroupVersionKind
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQuery) GetBundle(arg1 context.Context, arg2 string, arg3 string, arg4 string) (*api.Bundle, error) {
	fake.getBundleMutex.Lock()
	ret, specificReturn := fake.getBundleReturnsOnCall[len(fake.getBundleArgsForCall)]
	fake.getBundleArgsForCall = append(fake.getBundleArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("GetBundle", []interface{}{arg1, arg2, arg3, arg4})
	fake.getBundleMutex.Unlock()
	if fake.GetBundleStub != nil {
		return fake.GetBundleStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBundleReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) GetBundleCallCount() int {
	fake.getBundleMutex.RLock()
	defer fake.getBundleMutex.RUnlock()
	return len(fake.getBundleArgsForCall)
}

func (fake *FakeQuery) GetBundleCalls(stub func(context.Context, string, string, string) (*api.Bundle, error)) {
	fake.getBundleMutex.Lock()
	defer fake.getBundleMutex.Unlock()
	fake.GetBundleStub = stub
}

func (fake *FakeQuery) GetBundleArgsForCall(i int) (context.Context, string, string, string) {
	fake.getBundleMutex.RLock()
	defer fake.getBundleMutex.RUnlock()
	argsForCall := fake.getBundleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeQuery) GetBundleReturns(result1 *api.Bundle, result2 error) {
	fake.getBundleMutex.Lock()
	defer fake.getBundleMutex.Unlock()
	fake.GetBundleStub = nil
	fake.getBundleReturns = struct {
		result1 *api.Bundle
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetBundleReturnsOnCall(i int, result1 *api.Bundle, result2 error) {
	fake.getBundleMutex.Lock()
	defer fake.getBundleMutex.Unlock()
	fake.GetBundleStub = nil
	if fake.getBundleReturnsOnCall == nil {
		fake.getBundleReturnsOnCall = make(map[int]struct {
			result1 *api.Bundle
			result2 error
		})
	}
	fake.getBundleReturnsOnCall[i] = struct {
		result1 *api.Bundle
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetBundleForChannel(arg1 context.Context, arg2 string, arg3 string) (*api.Bundle, error) {
	fake.getBundleForChannelMutex.Lock()
	ret, specificReturn := fake.getBundleForChannelReturnsOnCall[len(fake.getBundleForChannelArgsForCall)]
	fake.getBundleForChannelArgsForCall = append(fake.getBundleForChannelArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetBundleForChannel", []interface{}{arg1, arg2, arg3})
	fake.getBundleForChannelMutex.Unlock()
	if fake.GetBundleForChannelStub != nil {
		return fake.GetBundleForChannelStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBundleForChannelReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) GetBundleForChannelCallCount() int {
	fake.getBundleForChannelMutex.RLock()
	defer fake.getBundleForChannelMutex.RUnlock()
	return len(fake.getBundleForChannelArgsForCall)
}

func (fake *FakeQuery) GetBundleForChannelCalls(stub func(context.Context, string, string) (*api.Bundle, error)) {
	fake.getBundleForChannelMutex.Lock()
	defer fake.getBundleForChannelMutex.Unlock()
	fake.GetBundleForChannelStub = stub
}

func (fake *FakeQuery) GetBundleForChannelArgsForCall(i int) (context.Context, string, string) {
	fake.getBundleForChannelMutex.RLock()
	defer fake.getBundleForChannelMutex.RUnlock()
	argsForCall := fake.getBundleForChannelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeQuery) GetBundleForChannelReturns(result1 *api.Bundle, result2 error) {
	fake.getBundleForChannelMutex.Lock()
	defer fake.getBundleForChannelMutex.Unlock()
	fake.GetBundleForChannelStub = nil
	fake.getBundleForChannelReturns = struct {
		result1 *api.Bundle
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetBundleForChannelReturnsOnCall(i int, result1 *api.Bundle, result2 error) {
	fake.getBundleForChannelMutex.Lock()
	defer fake.getBundleForChannelMutex.Unlock()
	fake.GetBundleForChannelStub = nil
	if fake.getBundleForChannelReturnsOnCall == nil {
		fake.getBundleForChannelReturnsOnCall = make(map[int]struct {
			result1 *api.Bundle
			result2 error
		})
	}
	fake.getBundleForChannelReturnsOnCall[i] = struct {
		result1 *api.Bundle
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetBundlePathIfExists(arg1 context.Context, arg2 string) (string, error) {
	fake.getBundlePathIfExistsMutex.Lock()
	ret, specificReturn := fake.getBundlePathIfExistsReturnsOnCall[len(fake.getBundlePathIfExistsArgsForCall)]
	fake.getBundlePathIfExistsArgsForCall = append(fake.getBundlePathIfExistsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetBundlePathIfExists", []interface{}{arg1, arg2})
	fake.getBundlePathIfExistsMutex.Unlock()
	if fake.GetBundlePathIfExistsStub != nil {
		return fake.GetBundlePathIfExistsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBundlePathIfExistsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) GetBundlePathIfExistsCallCount() int {
	fake.getBundlePathIfExistsMutex.RLock()
	defer fake.getBundlePathIfExistsMutex.RUnlock()
	return len(fake.getBundlePathIfExistsArgsForCall)
}

func (fake *FakeQuery) GetBundlePathIfExistsCalls(stub func(context.Context, string) (string, error)) {
	fake.getBundlePathIfExistsMutex.Lock()
	defer fake.getBundlePathIfExistsMutex.Unlock()
	fake.GetBundlePathIfExistsStub = stub
}

func (fake *FakeQuery) GetBundlePathIfExistsArgsForCall(i int) (context.Context, string) {
	fake.getBundlePathIfExistsMutex.RLock()
	defer fake.getBundlePathIfExistsMutex.RUnlock()
	argsForCall := fake.getBundlePathIfExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuery) GetBundlePathIfExistsReturns(result1 string, result2 error) {
	fake.getBundlePathIfExistsMutex.Lock()
	defer fake.getBundlePathIfExistsMutex.Unlock()
	fake.GetBundlePathIfExistsStub = nil
	fake.getBundlePathIfExistsReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetBundlePathIfExistsReturnsOnCall(i int, result1 string, result2 error) {
	fake.getBundlePathIfExistsMutex.Lock()
	defer fake.getBundlePathIfExistsMutex.Unlock()
	fake.GetBundlePathIfExistsStub = nil
	if fake.getBundlePathIfExistsReturnsOnCall == nil {
		fake.getBundlePathIfExistsReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getBundlePathIfExistsReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetBundlePathsForPackage(arg1 context.Context, arg2 string) ([]string, error) {
	fake.getBundlePathsForPackageMutex.Lock()
	ret, specificReturn := fake.getBundlePathsForPackageReturnsOnCall[len(fake.getBundlePathsForPackageArgsForCall)]
	fake.getBundlePathsForPackageArgsForCall = append(fake.getBundlePathsForPackageArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetBundlePathsForPackage", []interface{}{arg1, arg2})
	fake.getBundlePathsForPackageMutex.Unlock()
	if fake.GetBundlePathsForPackageStub != nil {
		return fake.GetBundlePathsForPackageStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBundlePathsForPackageReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) GetBundlePathsForPackageCallCount() int {
	fake.getBundlePathsForPackageMutex.RLock()
	defer fake.getBundlePathsForPackageMutex.RUnlock()
	return len(fake.getBundlePathsForPackageArgsForCall)
}

func (fake *FakeQuery) GetBundlePathsForPackageCalls(stub func(context.Context, string) ([]string, error)) {
	fake.getBundlePathsForPackageMutex.Lock()
	defer fake.getBundlePathsForPackageMutex.Unlock()
	fake.GetBundlePathsForPackageStub = stub
}

func (fake *FakeQuery) GetBundlePathsForPackageArgsForCall(i int) (context.Context, string) {
	fake.getBundlePathsForPackageMutex.RLock()
	defer fake.getBundlePathsForPackageMutex.RUnlock()
	argsForCall := fake.getBundlePathsForPackageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuery) GetBundlePathsForPackageReturns(result1 []string, result2 error) {
	fake.getBundlePathsForPackageMutex.Lock()
	defer fake.getBundlePathsForPackageMutex.Unlock()
	fake.GetBundlePathsForPackageStub = nil
	fake.getBundlePathsForPackageReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetBundlePathsForPackageReturnsOnCall(i int, result1 []string, result2 error) {
	fake.getBundlePathsForPackageMutex.Lock()
	defer fake.getBundlePathsForPackageMutex.Unlock()
	fake.GetBundlePathsForPackageStub = nil
	if fake.getBundlePathsForPackageReturnsOnCall == nil {
		fake.getBundlePathsForPackageReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getBundlePathsForPackageReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetBundleThatProvides(arg1 context.Context, arg2 string, arg3 string, arg4 string) (*api.Bundle, error) {
	fake.getBundleThatProvidesMutex.Lock()
	ret, specificReturn := fake.getBundleThatProvidesReturnsOnCall[len(fake.getBundleThatProvidesArgsForCall)]
	fake.getBundleThatProvidesArgsForCall = append(fake.getBundleThatProvidesArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("GetBundleThatProvides", []interface{}{arg1, arg2, arg3, arg4})
	fake.getBundleThatProvidesMutex.Unlock()
	if fake.GetBundleThatProvidesStub != nil {
		return fake.GetBundleThatProvidesStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBundleThatProvidesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) GetBundleThatProvidesCallCount() int {
	fake.getBundleThatProvidesMutex.RLock()
	defer fake.getBundleThatProvidesMutex.RUnlock()
	return len(fake.getBundleThatProvidesArgsForCall)
}

func (fake *FakeQuery) GetBundleThatProvidesCalls(stub func(context.Context, string, string, string) (*api.Bundle, error)) {
	fake.getBundleThatProvidesMutex.Lock()
	defer fake.getBundleThatProvidesMutex.Unlock()
	fake.GetBundleThatProvidesStub = stub
}

func (fake *FakeQuery) GetBundleThatProvidesArgsForCall(i int) (context.Context, string, string, string) {
	fake.getBundleThatProvidesMutex.RLock()
	defer fake.getBundleThatProvidesMutex.RUnlock()
	argsForCall := fake.getBundleThatProvidesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeQuery) GetBundleThatProvidesReturns(result1 *api.Bundle, result2 error) {
	fake.getBundleThatProvidesMutex.Lock()
	defer fake.getBundleThatProvidesMutex.Unlock()
	fake.GetBundleThatProvidesStub = nil
	fake.getBundleThatProvidesReturns = struct {
		result1 *api.Bundle
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetBundleThatProvidesReturnsOnCall(i int, result1 *api.Bundle, result2 error) {
	fake.getBundleThatProvidesMutex.Lock()
	defer fake.getBundleThatProvidesMutex.Unlock()
	fake.GetBundleThatProvidesStub = nil
	if fake.getBundleThatProvidesReturnsOnCall == nil {
		fake.getBundleThatProvidesReturnsOnCall = make(map[int]struct {
			result1 *api.Bundle
			result2 error
		})
	}
	fake.getBundleThatProvidesReturnsOnCall[i] = struct {
		result1 *api.Bundle
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetBundleThatReplaces(arg1 context.Context, arg2 string, arg3 string, arg4 string) (*api.Bundle, error) {
	fake.getBundleThatReplacesMutex.Lock()
	ret, specificReturn := fake.getBundleThatReplacesReturnsOnCall[len(fake.getBundleThatReplacesArgsForCall)]
	fake.getBundleThatReplacesArgsForCall = append(fake.getBundleThatReplacesArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("GetBundleThatReplaces", []interface{}{arg1, arg2, arg3, arg4})
	fake.getBundleThatReplacesMutex.Unlock()
	if fake.GetBundleThatReplacesStub != nil {
		return fake.GetBundleThatReplacesStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBundleThatReplacesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) GetBundleThatReplacesCallCount() int {
	fake.getBundleThatReplacesMutex.RLock()
	defer fake.getBundleThatReplacesMutex.RUnlock()
	return len(fake.getBundleThatReplacesArgsForCall)
}

func (fake *FakeQuery) GetBundleThatReplacesCalls(stub func(context.Context, string, string, string) (*api.Bundle, error)) {
	fake.getBundleThatReplacesMutex.Lock()
	defer fake.getBundleThatReplacesMutex.Unlock()
	fake.GetBundleThatReplacesStub = stub
}

func (fake *FakeQuery) GetBundleThatReplacesArgsForCall(i int) (context.Context, string, string, string) {
	fake.getBundleThatReplacesMutex.RLock()
	defer fake.getBundleThatReplacesMutex.RUnlock()
	argsForCall := fake.getBundleThatReplacesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeQuery) GetBundleThatReplacesReturns(result1 *api.Bundle, result2 error) {
	fake.getBundleThatReplacesMutex.Lock()
	defer fake.getBundleThatReplacesMutex.Unlock()
	fake.GetBundleThatReplacesStub = nil
	fake.getBundleThatReplacesReturns = struct {
		result1 *api.Bundle
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetBundleThatReplacesReturnsOnCall(i int, result1 *api.Bundle, result2 error) {
	fake.getBundleThatReplacesMutex.Lock()
	defer fake.getBundleThatReplacesMutex.Unlock()
	fake.GetBundleThatReplacesStub = nil
	if fake.getBundleThatReplacesReturnsOnCall == nil {
		fake.getBundleThatReplacesReturnsOnCall = make(map[int]struct {
			result1 *api.Bundle
			result2 error
		})
	}
	fake.getBundleThatReplacesReturnsOnCall[i] = struct {
		result1 *api.Bundle
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetBundleVersion(arg1 context.Context, arg2 string) (string, error) {
	fake.getBundleVersionMutex.Lock()
	ret, specificReturn := fake.getBundleVersionReturnsOnCall[len(fake.getBundleVersionArgsForCall)]
	fake.getBundleVersionArgsForCall = append(fake.getBundleVersionArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetBundleVersion", []interface{}{arg1, arg2})
	fake.getBundleVersionMutex.Unlock()
	if fake.GetBundleVersionStub != nil {
		return fake.GetBundleVersionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBundleVersionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) GetBundleVersionCallCount() int {
	fake.getBundleVersionMutex.RLock()
	defer fake.getBundleVersionMutex.RUnlock()
	return len(fake.getBundleVersionArgsForCall)
}

func (fake *FakeQuery) GetBundleVersionCalls(stub func(context.Context, string) (string, error)) {
	fake.getBundleVersionMutex.Lock()
	defer fake.getBundleVersionMutex.Unlock()
	fake.GetBundleVersionStub = stub
}

func (fake *FakeQuery) GetBundleVersionArgsForCall(i int) (context.Context, string) {
	fake.getBundleVersionMutex.RLock()
	defer fake.getBundleVersionMutex.RUnlock()
	argsForCall := fake.getBundleVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuery) GetBundleVersionReturns(result1 string, result2 error) {
	fake.getBundleVersionMutex.Lock()
	defer fake.getBundleVersionMutex.Unlock()
	fake.GetBundleVersionStub = nil
	fake.getBundleVersionReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetBundleVersionReturnsOnCall(i int, result1 string, result2 error) {
	fake.getBundleVersionMutex.Lock()
	defer fake.getBundleVersionMutex.Unlock()
	fake.GetBundleVersionStub = nil
	if fake.getBundleVersionReturnsOnCall == nil {
		fake.getBundleVersionReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getBundleVersionReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetBundlesForPackage(arg1 context.Context, arg2 string) (map[registry.BundleKey]struct{}, error) {
	fake.getBundlesForPackageMutex.Lock()
	ret, specificReturn := fake.getBundlesForPackageReturnsOnCall[len(fake.getBundlesForPackageArgsForCall)]
	fake.getBundlesForPackageArgsForCall = append(fake.getBundlesForPackageArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetBundlesForPackage", []interface{}{arg1, arg2})
	fake.getBundlesForPackageMutex.Unlock()
	if fake.GetBundlesForPackageStub != nil {
		return fake.GetBundlesForPackageStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBundlesForPackageReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) GetBundlesForPackageCallCount() int {
	fake.getBundlesForPackageMutex.RLock()
	defer fake.getBundlesForPackageMutex.RUnlock()
	return len(fake.getBundlesForPackageArgsForCall)
}

func (fake *FakeQuery) GetBundlesForPackageCalls(stub func(context.Context, string) (map[registry.BundleKey]struct{}, error)) {
	fake.getBundlesForPackageMutex.Lock()
	defer fake.getBundlesForPackageMutex.Unlock()
	fake.GetBundlesForPackageStub = stub
}

func (fake *FakeQuery) GetBundlesForPackageArgsForCall(i int) (context.Context, string) {
	fake.getBundlesForPackageMutex.RLock()
	defer fake.getBundlesForPackageMutex.RUnlock()
	argsForCall := fake.getBundlesForPackageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuery) GetBundlesForPackageReturns(result1 map[registry.BundleKey]struct{}, result2 error) {
	fake.getBundlesForPackageMutex.Lock()
	defer fake.getBundlesForPackageMutex.Unlock()
	fake.GetBundlesForPackageStub = nil
	fake.getBundlesForPackageReturns = struct {
		result1 map[registry.BundleKey]struct{}
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetBundlesForPackageReturnsOnCall(i int, result1 map[registry.BundleKey]struct{}, result2 error) {
	fake.getBundlesForPackageMutex.Lock()
	defer fake.getBundlesForPackageMutex.Unlock()
	fake.GetBundlesForPackageStub = nil
	if fake.getBundlesForPackageReturnsOnCall == nil {
		fake.getBundlesForPackageReturnsOnCall = make(map[int]struct {
			result1 map[registry.BundleKey]struct{}
			result2 error
		})
	}
	fake.getBundlesForPackageReturnsOnCall[i] = struct {
		result1 map[registry.BundleKey]struct{}
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetChannelEntriesFromPackage(arg1 context.Context, arg2 string) ([]registry.ChannelEntryAnnotated, error) {
	fake.getChannelEntriesFromPackageMutex.Lock()
	ret, specificReturn := fake.getChannelEntriesFromPackageReturnsOnCall[len(fake.getChannelEntriesFromPackageArgsForCall)]
	fake.getChannelEntriesFromPackageArgsForCall = append(fake.getChannelEntriesFromPackageArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetChannelEntriesFromPackage", []interface{}{arg1, arg2})
	fake.getChannelEntriesFromPackageMutex.Unlock()
	if fake.GetChannelEntriesFromPackageStub != nil {
		return fake.GetChannelEntriesFromPackageStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getChannelEntriesFromPackageReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) GetChannelEntriesFromPackageCallCount() int {
	fake.getChannelEntriesFromPackageMutex.RLock()
	defer fake.getChannelEntriesFromPackageMutex.RUnlock()
	return len(fake.getChannelEntriesFromPackageArgsForCall)
}

func (fake *FakeQuery) GetChannelEntriesFromPackageCalls(stub func(context.Context, string) ([]registry.ChannelEntryAnnotated, error)) {
	fake.getChannelEntriesFromPackageMutex.Lock()
	defer fake.getChannelEntriesFromPackageMutex.Unlock()
	fake.GetChannelEntriesFromPackageStub = stub
}

func (fake *FakeQuery) GetChannelEntriesFromPackageArgsForCall(i int) (context.Context, string) {
	fake.getChannelEntriesFromPackageMutex.RLock()
	defer fake.getChannelEntriesFromPackageMutex.RUnlock()
	argsForCall := fake.getChannelEntriesFromPackageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuery) GetChannelEntriesFromPackageReturns(result1 []registry.ChannelEntryAnnotated, result2 error) {
	fake.getChannelEntriesFromPackageMutex.Lock()
	defer fake.getChannelEntriesFromPackageMutex.Unlock()
	fake.GetChannelEntriesFromPackageStub = nil
	fake.getChannelEntriesFromPackageReturns = struct {
		result1 []registry.ChannelEntryAnnotated
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetChannelEntriesFromPackageReturnsOnCall(i int, result1 []registry.ChannelEntryAnnotated, result2 error) {
	fake.getChannelEntriesFromPackageMutex.Lock()
	defer fake.getChannelEntriesFromPackageMutex.Unlock()
	fake.GetChannelEntriesFromPackageStub = nil
	if fake.getChannelEntriesFromPackageReturnsOnCall == nil {
		fake.getChannelEntriesFromPackageReturnsOnCall = make(map[int]struct {
			result1 []registry.ChannelEntryAnnotated
			result2 error
		})
	}
	fake.getChannelEntriesFromPackageReturnsOnCall[i] = struct {
		result1 []registry.ChannelEntryAnnotated
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetChannelEntriesThatProvide(arg1 context.Context, arg2 string, arg3 string, arg4 string) ([]*registry.ChannelEntry, error) {
	fake.getChannelEntriesThatProvideMutex.Lock()
	ret, specificReturn := fake.getChannelEntriesThatProvideReturnsOnCall[len(fake.getChannelEntriesThatProvideArgsForCall)]
	fake.getChannelEntriesThatProvideArgsForCall = append(fake.getChannelEntriesThatProvideArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("GetChannelEntriesThatProvide", []interface{}{arg1, arg2, arg3, arg4})
	fake.getChannelEntriesThatProvideMutex.Unlock()
	if fake.GetChannelEntriesThatProvideStub != nil {
		return fake.GetChannelEntriesThatProvideStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getChannelEntriesThatProvideReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) GetChannelEntriesThatProvideCallCount() int {
	fake.getChannelEntriesThatProvideMutex.RLock()
	defer fake.getChannelEntriesThatProvideMutex.RUnlock()
	return len(fake.getChannelEntriesThatProvideArgsForCall)
}

func (fake *FakeQuery) GetChannelEntriesThatProvideCalls(stub func(context.Context, string, string, string) ([]*registry.ChannelEntry, error)) {
	fake.getChannelEntriesThatProvideMutex.Lock()
	defer fake.getChannelEntriesThatProvideMutex.Unlock()
	fake.GetChannelEntriesThatProvideStub = stub
}

func (fake *FakeQuery) GetChannelEntriesThatProvideArgsForCall(i int) (context.Context, string, string, string) {
	fake.getChannelEntriesThatProvideMutex.RLock()
	defer fake.getChannelEntriesThatProvideMutex.RUnlock()
	argsForCall := fake.getChannelEntriesThatProvideArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeQuery) GetChannelEntriesThatProvideReturns(result1 []*registry.ChannelEntry, result2 error) {
	fake.getChannelEntriesThatProvideMutex.Lock()
	defer fake.getChannelEntriesThatProvideMutex.Unlock()
	fake.GetChannelEntriesThatProvideStub = nil
	fake.getChannelEntriesThatProvideReturns = struct {
		result1 []*registry.ChannelEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetChannelEntriesThatProvideReturnsOnCall(i int, result1 []*registry.ChannelEntry, result2 error) {
	fake.getChannelEntriesThatProvideMutex.Lock()
	defer fake.getChannelEntriesThatProvideMutex.Unlock()
	fake.GetChannelEntriesThatProvideStub = nil
	if fake.getChannelEntriesThatProvideReturnsOnCall == nil {
		fake.getChannelEntriesThatProvideReturnsOnCall = make(map[int]struct {
			result1 []*registry.ChannelEntry
			result2 error
		})
	}
	fake.getChannelEntriesThatProvideReturnsOnCall[i] = struct {
		result1 []*registry.ChannelEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetChannelEntriesThatReplace(arg1 context.Context, arg2 string) ([]*registry.ChannelEntry, error) {
	fake.getChannelEntriesThatReplaceMutex.Lock()
	ret, specificReturn := fake.getChannelEntriesThatReplaceReturnsOnCall[len(fake.getChannelEntriesThatReplaceArgsForCall)]
	fake.getChannelEntriesThatReplaceArgsForCall = append(fake.getChannelEntriesThatReplaceArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetChannelEntriesThatReplace", []interface{}{arg1, arg2})
	fake.getChannelEntriesThatReplaceMutex.Unlock()
	if fake.GetChannelEntriesThatReplaceStub != nil {
		return fake.GetChannelEntriesThatReplaceStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getChannelEntriesThatReplaceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) GetChannelEntriesThatReplaceCallCount() int {
	fake.getChannelEntriesThatReplaceMutex.RLock()
	defer fake.getChannelEntriesThatReplaceMutex.RUnlock()
	return len(fake.getChannelEntriesThatReplaceArgsForCall)
}

func (fake *FakeQuery) GetChannelEntriesThatReplaceCalls(stub func(context.Context, string) ([]*registry.ChannelEntry, error)) {
	fake.getChannelEntriesThatReplaceMutex.Lock()
	defer fake.getChannelEntriesThatReplaceMutex.Unlock()
	fake.GetChannelEntriesThatReplaceStub = stub
}

func (fake *FakeQuery) GetChannelEntriesThatReplaceArgsForCall(i int) (context.Context, string) {
	fake.getChannelEntriesThatReplaceMutex.RLock()
	defer fake.getChannelEntriesThatReplaceMutex.RUnlock()
	argsForCall := fake.getChannelEntriesThatReplaceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuery) GetChannelEntriesThatReplaceReturns(result1 []*registry.ChannelEntry, result2 error) {
	fake.getChannelEntriesThatReplaceMutex.Lock()
	defer fake.getChannelEntriesThatReplaceMutex.Unlock()
	fake.GetChannelEntriesThatReplaceStub = nil
	fake.getChannelEntriesThatReplaceReturns = struct {
		result1 []*registry.ChannelEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetChannelEntriesThatReplaceReturnsOnCall(i int, result1 []*registry.ChannelEntry, result2 error) {
	fake.getChannelEntriesThatReplaceMutex.Lock()
	defer fake.getChannelEntriesThatReplaceMutex.Unlock()
	fake.GetChannelEntriesThatReplaceStub = nil
	if fake.getChannelEntriesThatReplaceReturnsOnCall == nil {
		fake.getChannelEntriesThatReplaceReturnsOnCall = make(map[int]struct {
			result1 []*registry.ChannelEntry
			result2 error
		})
	}
	fake.getChannelEntriesThatReplaceReturnsOnCall[i] = struct {
		result1 []*registry.ChannelEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetCurrentCSVNameForChannel(arg1 context.Context, arg2 string, arg3 string) (string, error) {
	fake.getCurrentCSVNameForChannelMutex.Lock()
	ret, specificReturn := fake.getCurrentCSVNameForChannelReturnsOnCall[len(fake.getCurrentCSVNameForChannelArgsForCall)]
	fake.getCurrentCSVNameForChannelArgsForCall = append(fake.getCurrentCSVNameForChannelArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetCurrentCSVNameForChannel", []interface{}{arg1, arg2, arg3})
	fake.getCurrentCSVNameForChannelMutex.Unlock()
	if fake.GetCurrentCSVNameForChannelStub != nil {
		return fake.GetCurrentCSVNameForChannelStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getCurrentCSVNameForChannelReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) GetCurrentCSVNameForChannelCallCount() int {
	fake.getCurrentCSVNameForChannelMutex.RLock()
	defer fake.getCurrentCSVNameForChannelMutex.RUnlock()
	return len(fake.getCurrentCSVNameForChannelArgsForCall)
}

func (fake *FakeQuery) GetCurrentCSVNameForChannelCalls(stub func(context.Context, string, string) (string, error)) {
	fake.getCurrentCSVNameForChannelMutex.Lock()
	defer fake.getCurrentCSVNameForChannelMutex.Unlock()
	fake.GetCurrentCSVNameForChannelStub = stub
}

func (fake *FakeQuery) GetCurrentCSVNameForChannelArgsForCall(i int) (context.Context, string, string) {
	fake.getCurrentCSVNameForChannelMutex.RLock()
	defer fake.getCurrentCSVNameForChannelMutex.RUnlock()
	argsForCall := fake.getCurrentCSVNameForChannelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeQuery) GetCurrentCSVNameForChannelReturns(result1 string, result2 error) {
	fake.getCurrentCSVNameForChannelMutex.Lock()
	defer fake.getCurrentCSVNameForChannelMutex.Unlock()
	fake.GetCurrentCSVNameForChannelStub = nil
	fake.getCurrentCSVNameForChannelReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetCurrentCSVNameForChannelReturnsOnCall(i int, result1 string, result2 error) {
	fake.getCurrentCSVNameForChannelMutex.Lock()
	defer fake.getCurrentCSVNameForChannelMutex.Unlock()
	fake.GetCurrentCSVNameForChannelStub = nil
	if fake.getCurrentCSVNameForChannelReturnsOnCall == nil {
		fake.getCurrentCSVNameForChannelReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getCurrentCSVNameForChannelReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetDefaultChannelForPackage(arg1 context.Context, arg2 string) (string, error) {
	fake.getDefaultChannelForPackageMutex.Lock()
	ret, specificReturn := fake.getDefaultChannelForPackageReturnsOnCall[len(fake.getDefaultChannelForPackageArgsForCall)]
	fake.getDefaultChannelForPackageArgsForCall = append(fake.getDefaultChannelForPackageArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetDefaultChannelForPackage", []interface{}{arg1, arg2})
	fake.getDefaultChannelForPackageMutex.Unlock()
	if fake.GetDefaultChannelForPackageStub != nil {
		return fake.GetDefaultChannelForPackageStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getDefaultChannelForPackageReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) GetDefaultChannelForPackageCallCount() int {
	fake.getDefaultChannelForPackageMutex.RLock()
	defer fake.getDefaultChannelForPackageMutex.RUnlock()
	return len(fake.getDefaultChannelForPackageArgsForCall)
}

func (fake *FakeQuery) GetDefaultChannelForPackageCalls(stub func(context.Context, string) (string, error)) {
	fake.getDefaultChannelForPackageMutex.Lock()
	defer fake.getDefaultChannelForPackageMutex.Unlock()
	fake.GetDefaultChannelForPackageStub = stub
}

func (fake *FakeQuery) GetDefaultChannelForPackageArgsForCall(i int) (context.Context, string) {
	fake.getDefaultChannelForPackageMutex.RLock()
	defer fake.getDefaultChannelForPackageMutex.RUnlock()
	argsForCall := fake.getDefaultChannelForPackageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuery) GetDefaultChannelForPackageReturns(result1 string, result2 error) {
	fake.getDefaultChannelForPackageMutex.Lock()
	defer fake.getDefaultChannelForPackageMutex.Unlock()
	fake.GetDefaultChannelForPackageStub = nil
	fake.getDefaultChannelForPackageReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetDefaultChannelForPackageReturnsOnCall(i int, result1 string, result2 error) {
	fake.getDefaultChannelForPackageMutex.Lock()
	defer fake.getDefaultChannelForPackageMutex.Unlock()
	fake.GetDefaultChannelForPackageStub = nil
	if fake.getDefaultChannelForPackageReturnsOnCall == nil {
		fake.getDefaultChannelForPackageReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getDefaultChannelForPackageReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetDefaultPackage(arg1 context.Context, arg2 string) (string, error) {
	fake.getDefaultPackageMutex.Lock()
	ret, specificReturn := fake.getDefaultPackageReturnsOnCall[len(fake.getDefaultPackageArgsForCall)]
	fake.getDefaultPackageArgsForCall = append(fake.getDefaultPackageArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetDefaultPackage", []interface{}{arg1, arg2})
	fake.getDefaultPackageMutex.Unlock()
	if fake.GetDefaultPackageStub != nil {
		return fake.GetDefaultPackageStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getDefaultPackageReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) GetDefaultPackageCallCount() int {
	fake.getDefaultPackageMutex.RLock()
	defer fake.getDefaultPackageMutex.RUnlock()
	return len(fake.getDefaultPackageArgsForCall)
}

func (fake *FakeQuery) GetDefaultPackageCalls(stub func(context.Context, string) (string, error)) {
	fake.getDefaultPackageMutex.Lock()
	defer fake.getDefaultPackageMutex.Unlock()
	fake.GetDefaultPackageStub = stub
}

func (fake *FakeQuery) GetDefaultPackageArgsForCall(i int) (context.Context, string) {
	fake.getDefaultPackageMutex.RLock()
	defer fake.getDefaultPackageMutex.RUnlock()
	argsForCall := fake.getDefaultPackageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuery) GetDefaultPackageReturns(result1 string, result2 error) {
	fake.getDefaultPackageMutex.Lock()
	defer fake.getDefaultPackageMutex.Unlock()
	fake.GetDefaultPackageStub = nil
	fake.getDefaultPackageReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetDefaultPackageReturnsOnCall(i int, result1 string, result2 error) {
	fake.getDefaultPackageMutex.Lock()
	defer fake.getDefaultPackageMutex.Unlock()
	fake.GetDefaultPackageStub = nil
	if fake.getDefaultPackageReturnsOnCall == nil {
		fake.getDefaultPackageReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getDefaultPackageReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetDependenciesForBundle(arg1 context.Context, arg2 string, arg3 string, arg4 string) ([]*api.Dependency, error) {
	fake.getDependenciesForBundleMutex.Lock()
	ret, specificReturn := fake.getDependenciesForBundleReturnsOnCall[len(fake.getDependenciesForBundleArgsForCall)]
	fake.getDependenciesForBundleArgsForCall = append(fake.getDependenciesForBundleArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("GetDependenciesForBundle", []interface{}{arg1, arg2, arg3, arg4})
	fake.getDependenciesForBundleMutex.Unlock()
	if fake.GetDependenciesForBundleStub != nil {
		return fake.GetDependenciesForBundleStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getDependenciesForBundleReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) GetDependenciesForBundleCallCount() int {
	fake.getDependenciesForBundleMutex.RLock()
	defer fake.getDependenciesForBundleMutex.RUnlock()
	return len(fake.getDependenciesForBundleArgsForCall)
}

func (fake *FakeQuery) GetDependenciesForBundleCalls(stub func(context.Context, string, string, string) ([]*api.Dependency, error)) {
	fake.getDependenciesForBundleMutex.Lock()
	defer fake.getDependenciesForBundleMutex.Unlock()
	fake.GetDependenciesForBundleStub = stub
}

func (fake *FakeQuery) GetDependenciesForBundleArgsForCall(i int) (context.Context, string, string, string) {
	fake.getDependenciesForBundleMutex.RLock()
	defer fake.getDependenciesForBundleMutex.RUnlock()
	argsForCall := fake.getDependenciesForBundleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeQuery) GetDependenciesForBundleReturns(result1 []*api.Dependency, result2 error) {
	fake.getDependenciesForBundleMutex.Lock()
	defer fake.getDependenciesForBundleMutex.Unlock()
	fake.GetDependenciesForBundleStub = nil
	fake.getDependenciesForBundleReturns = struct {
		result1 []*api.Dependency
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetDependenciesForBundleReturnsOnCall(i int, result1 []*api.Dependency, result2 error) {
	fake.getDependenciesForBundleMutex.Lock()
	defer fake.getDependenciesForBundleMutex.Unlock()
	fake.GetDependenciesForBundleStub = nil
	if fake.getDependenciesForBundleReturnsOnCall == nil {
		fake.getDependenciesForBundleReturnsOnCall = make(map[int]struct {
			result1 []*api.Dependency
			result2 error
		})
	}
	fake.getDependenciesForBundleReturnsOnCall[i] = struct {
		result1 []*api.Dependency
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetImagesForBundle(arg1 context.Context, arg2 string) ([]string, error) {
	fake.getImagesForBundleMutex.Lock()
	ret, specificReturn := fake.getImagesForBundleReturnsOnCall[len(fake.getImagesForBundleArgsForCall)]
	fake.getImagesForBundleArgsForCall = append(fake.getImagesForBundleArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetImagesForBundle", []interface{}{arg1, arg2})
	fake.getImagesForBundleMutex.Unlock()
	if fake.GetImagesForBundleStub != nil {
		return fake.GetImagesForBundleStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getImagesForBundleReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) GetImagesForBundleCallCount() int {
	fake.getImagesForBundleMutex.RLock()
	defer fake.getImagesForBundleMutex.RUnlock()
	return len(fake.getImagesForBundleArgsForCall)
}

func (fake *FakeQuery) GetImagesForBundleCalls(stub func(context.Context, string) ([]string, error)) {
	fake.getImagesForBundleMutex.Lock()
	defer fake.getImagesForBundleMutex.Unlock()
	fake.GetImagesForBundleStub = stub
}

func (fake *FakeQuery) GetImagesForBundleArgsForCall(i int) (context.Context, string) {
	fake.getImagesForBundleMutex.RLock()
	defer fake.getImagesForBundleMutex.RUnlock()
	argsForCall := fake.getImagesForBundleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuery) GetImagesForBundleReturns(result1 []string, result2 error) {
	fake.getImagesForBundleMutex.Lock()
	defer fake.getImagesForBundleMutex.Unlock()
	fake.GetImagesForBundleStub = nil
	fake.getImagesForBundleReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetImagesForBundleReturnsOnCall(i int, result1 []string, result2 error) {
	fake.getImagesForBundleMutex.Lock()
	defer fake.getImagesForBundleMutex.Unlock()
	fake.GetImagesForBundleStub = nil
	if fake.getImagesForBundleReturnsOnCall == nil {
		fake.getImagesForBundleReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getImagesForBundleReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetLatestChannelEntriesThatProvide(arg1 context.Context, arg2 string, arg3 string, arg4 string) ([]*registry.ChannelEntry, error) {
	fake.getLatestChannelEntriesThatProvideMutex.Lock()
	ret, specificReturn := fake.getLatestChannelEntriesThatProvideReturnsOnCall[len(fake.getLatestChannelEntriesThatProvideArgsForCall)]
	fake.getLatestChannelEntriesThatProvideArgsForCall = append(fake.getLatestChannelEntriesThatProvideArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("GetLatestChannelEntriesThatProvide", []interface{}{arg1, arg2, arg3, arg4})
	fake.getLatestChannelEntriesThatProvideMutex.Unlock()
	if fake.GetLatestChannelEntriesThatProvideStub != nil {
		return fake.GetLatestChannelEntriesThatProvideStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getLatestChannelEntriesThatProvideReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) GetLatestChannelEntriesThatProvideCallCount() int {
	fake.getLatestChannelEntriesThatProvideMutex.RLock()
	defer fake.getLatestChannelEntriesThatProvideMutex.RUnlock()
	return len(fake.getLatestChannelEntriesThatProvideArgsForCall)
}

func (fake *FakeQuery) GetLatestChannelEntriesThatProvideCalls(stub func(context.Context, string, string, string) ([]*registry.ChannelEntry, error)) {
	fake.getLatestChannelEntriesThatProvideMutex.Lock()
	defer fake.getLatestChannelEntriesThatProvideMutex.Unlock()
	fake.GetLatestChannelEntriesThatProvideStub = stub
}

func (fake *FakeQuery) GetLatestChannelEntriesThatProvideArgsForCall(i int) (context.Context, string, string, string) {
	fake.getLatestChannelEntriesThatProvideMutex.RLock()
	defer fake.getLatestChannelEntriesThatProvideMutex.RUnlock()
	argsForCall := fake.getLatestChannelEntriesThatProvideArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeQuery) GetLatestChannelEntriesThatProvideReturns(result1 []*registry.ChannelEntry, result2 error) {
	fake.getLatestChannelEntriesThatProvideMutex.Lock()
	defer fake.getLatestChannelEntriesThatProvideMutex.Unlock()
	fake.GetLatestChannelEntriesThatProvideStub = nil
	fake.getLatestChannelEntriesThatProvideReturns = struct {
		result1 []*registry.ChannelEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetLatestChannelEntriesThatProvideReturnsOnCall(i int, result1 []*registry.ChannelEntry, result2 error) {
	fake.getLatestChannelEntriesThatProvideMutex.Lock()
	defer fake.getLatestChannelEntriesThatProvideMutex.Unlock()
	fake.GetLatestChannelEntriesThatProvideStub = nil
	if fake.getLatestChannelEntriesThatProvideReturnsOnCall == nil {
		fake.getLatestChannelEntriesThatProvideReturnsOnCall = make(map[int]struct {
			result1 []*registry.ChannelEntry
			result2 error
		})
	}
	fake.getLatestChannelEntriesThatProvideReturnsOnCall[i] = struct {
		result1 []*registry.ChannelEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetPackage(arg1 context.Context, arg2 string) (*registry.PackageManifest, error) {
	fake.getPackageMutex.Lock()
	ret, specificReturn := fake.getPackageReturnsOnCall[len(fake.getPackageArgsForCall)]
	fake.getPackageArgsForCall = append(fake.getPackageArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetPackage", []interface{}{arg1, arg2})
	fake.getPackageMutex.Unlock()
	if fake.GetPackageStub != nil {
		return fake.GetPackageStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getPackageReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) GetPackageCallCount() int {
	fake.getPackageMutex.RLock()
	defer fake.getPackageMutex.RUnlock()
	return len(fake.getPackageArgsForCall)
}

func (fake *FakeQuery) GetPackageCalls(stub func(context.Context, string) (*registry.PackageManifest, error)) {
	fake.getPackageMutex.Lock()
	defer fake.getPackageMutex.Unlock()
	fake.GetPackageStub = stub
}

func (fake *FakeQuery) GetPackageArgsForCall(i int) (context.Context, string) {
	fake.getPackageMutex.RLock()
	defer fake.getPackageMutex.RUnlock()
	argsForCall := fake.getPackageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuery) GetPackageReturns(result1 *registry.PackageManifest, result2 error) {
	fake.getPackageMutex.Lock()
	defer fake.getPackageMutex.Unlock()
	fake.GetPackageStub = nil
	fake.getPackageReturns = struct {
		result1 *registry.PackageManifest
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) GetPackageReturnsOnCall(i int, result1 *registry.PackageManifest, result2 error) {
	fake.getPackageMutex.Lock()
	defer fake.getPackageMutex.Unlock()
	fake.GetPackageStub = nil
	if fake.getPackageReturnsOnCall == nil {
		fake.getPackageReturnsOnCall = make(map[int]struct {
			result1 *registry.PackageManifest
			result2 error
		})
	}
	fake.getPackageReturnsOnCall[i] = struct {
		result1 *registry.PackageManifest
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) ListBundles(arg1 context.Context) ([]*api.Bundle, error) {
	fake.listBundlesMutex.Lock()
	ret, specificReturn := fake.listBundlesReturnsOnCall[len(fake.listBundlesArgsForCall)]
	fake.listBundlesArgsForCall = append(fake.listBundlesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("ListBundles", []interface{}{arg1})
	fake.listBundlesMutex.Unlock()
	if fake.ListBundlesStub != nil {
		return fake.ListBundlesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listBundlesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) ListBundlesCallCount() int {
	fake.listBundlesMutex.RLock()
	defer fake.listBundlesMutex.RUnlock()
	return len(fake.listBundlesArgsForCall)
}

func (fake *FakeQuery) ListBundlesCalls(stub func(context.Context) ([]*api.Bundle, error)) {
	fake.listBundlesMutex.Lock()
	defer fake.listBundlesMutex.Unlock()
	fake.ListBundlesStub = stub
}

func (fake *FakeQuery) ListBundlesArgsForCall(i int) context.Context {
	fake.listBundlesMutex.RLock()
	defer fake.listBundlesMutex.RUnlock()
	argsForCall := fake.listBundlesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQuery) ListBundlesReturns(result1 []*api.Bundle, result2 error) {
	fake.listBundlesMutex.Lock()
	defer fake.listBundlesMutex.Unlock()
	fake.ListBundlesStub = nil
	fake.listBundlesReturns = struct {
		result1 []*api.Bundle
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) ListBundlesReturnsOnCall(i int, result1 []*api.Bundle, result2 error) {
	fake.listBundlesMutex.Lock()
	defer fake.listBundlesMutex.Unlock()
	fake.ListBundlesStub = nil
	if fake.listBundlesReturnsOnCall == nil {
		fake.listBundlesReturnsOnCall = make(map[int]struct {
			result1 []*api.Bundle
			result2 error
		})
	}
	fake.listBundlesReturnsOnCall[i] = struct {
		result1 []*api.Bundle
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) ListChannels(arg1 context.Context, arg2 string) ([]string, error) {
	fake.listChannelsMutex.Lock()
	ret, specificReturn := fake.listChannelsReturnsOnCall[len(fake.listChannelsArgsForCall)]
	fake.listChannelsArgsForCall = append(fake.listChannelsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ListChannels", []interface{}{arg1, arg2})
	fake.listChannelsMutex.Unlock()
	if fake.ListChannelsStub != nil {
		return fake.ListChannelsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listChannelsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) ListChannelsCallCount() int {
	fake.listChannelsMutex.RLock()
	defer fake.listChannelsMutex.RUnlock()
	return len(fake.listChannelsArgsForCall)
}

func (fake *FakeQuery) ListChannelsCalls(stub func(context.Context, string) ([]string, error)) {
	fake.listChannelsMutex.Lock()
	defer fake.listChannelsMutex.Unlock()
	fake.ListChannelsStub = stub
}

func (fake *FakeQuery) ListChannelsArgsForCall(i int) (context.Context, string) {
	fake.listChannelsMutex.RLock()
	defer fake.listChannelsMutex.RUnlock()
	argsForCall := fake.listChannelsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuery) ListChannelsReturns(result1 []string, result2 error) {
	fake.listChannelsMutex.Lock()
	defer fake.listChannelsMutex.Unlock()
	fake.ListChannelsStub = nil
	fake.listChannelsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) ListChannelsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.listChannelsMutex.Lock()
	defer fake.listChannelsMutex.Unlock()
	fake.ListChannelsStub = nil
	if fake.listChannelsReturnsOnCall == nil {
		fake.listChannelsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listChannelsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) ListImages(arg1 context.Context) ([]string, error) {
	fake.listImagesMutex.Lock()
	ret, specificReturn := fake.listImagesReturnsOnCall[len(fake.listImagesArgsForCall)]
	fake.listImagesArgsForCall = append(fake.listImagesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("ListImages", []interface{}{arg1})
	fake.listImagesMutex.Unlock()
	if fake.ListImagesStub != nil {
		return fake.ListImagesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listImagesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) ListImagesCallCount() int {
	fake.listImagesMutex.RLock()
	defer fake.listImagesMutex.RUnlock()
	return len(fake.listImagesArgsForCall)
}

func (fake *FakeQuery) ListImagesCalls(stub func(context.Context) ([]string, error)) {
	fake.listImagesMutex.Lock()
	defer fake.listImagesMutex.Unlock()
	fake.ListImagesStub = stub
}

func (fake *FakeQuery) ListImagesArgsForCall(i int) context.Context {
	fake.listImagesMutex.RLock()
	defer fake.listImagesMutex.RUnlock()
	argsForCall := fake.listImagesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQuery) ListImagesReturns(result1 []string, result2 error) {
	fake.listImagesMutex.Lock()
	defer fake.listImagesMutex.Unlock()
	fake.ListImagesStub = nil
	fake.listImagesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) ListImagesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.listImagesMutex.Lock()
	defer fake.listImagesMutex.Unlock()
	fake.ListImagesStub = nil
	if fake.listImagesReturnsOnCall == nil {
		fake.listImagesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listImagesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) ListPackages(arg1 context.Context) ([]string, error) {
	fake.listPackagesMutex.Lock()
	ret, specificReturn := fake.listPackagesReturnsOnCall[len(fake.listPackagesArgsForCall)]
	fake.listPackagesArgsForCall = append(fake.listPackagesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("ListPackages", []interface{}{arg1})
	fake.listPackagesMutex.Unlock()
	if fake.ListPackagesStub != nil {
		return fake.ListPackagesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listPackagesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) ListPackagesCallCount() int {
	fake.listPackagesMutex.RLock()
	defer fake.listPackagesMutex.RUnlock()
	return len(fake.listPackagesArgsForCall)
}

func (fake *FakeQuery) ListPackagesCalls(stub func(context.Context) ([]string, error)) {
	fake.listPackagesMutex.Lock()
	defer fake.listPackagesMutex.Unlock()
	fake.ListPackagesStub = stub
}

func (fake *FakeQuery) ListPackagesArgsForCall(i int) context.Context {
	fake.listPackagesMutex.RLock()
	defer fake.listPackagesMutex.RUnlock()
	argsForCall := fake.listPackagesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQuery) ListPackagesReturns(result1 []string, result2 error) {
	fake.listPackagesMutex.Lock()
	defer fake.listPackagesMutex.Unlock()
	fake.ListPackagesStub = nil
	fake.listPackagesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) ListPackagesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.listPackagesMutex.Lock()
	defer fake.listPackagesMutex.Unlock()
	fake.ListPackagesStub = nil
	if fake.listPackagesReturnsOnCall == nil {
		fake.listPackagesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listPackagesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) ListRegistryBundles(arg1 context.Context) ([]*registry.Bundle, error) {
	fake.listRegistryBundlesMutex.Lock()
	ret, specificReturn := fake.listRegistryBundlesReturnsOnCall[len(fake.listRegistryBundlesArgsForCall)]
	fake.listRegistryBundlesArgsForCall = append(fake.listRegistryBundlesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("ListRegistryBundles", []interface{}{arg1})
	fake.listRegistryBundlesMutex.Unlock()
	if fake.ListRegistryBundlesStub != nil {
		return fake.ListRegistryBundlesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listRegistryBundlesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) ListRegistryBundlesCallCount() int {
	fake.listRegistryBundlesMutex.RLock()
	defer fake.listRegistryBundlesMutex.RUnlock()
	return len(fake.listRegistryBundlesArgsForCall)
}

func (fake *FakeQuery) ListRegistryBundlesCalls(stub func(context.Context) ([]*registry.Bundle, error)) {
	fake.listRegistryBundlesMutex.Lock()
	defer fake.listRegistryBundlesMutex.Unlock()
	fake.ListRegistryBundlesStub = stub
}

func (fake *FakeQuery) ListRegistryBundlesArgsForCall(i int) context.Context {
	fake.listRegistryBundlesMutex.RLock()
	defer fake.listRegistryBundlesMutex.RUnlock()
	argsForCall := fake.listRegistryBundlesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQuery) ListRegistryBundlesReturns(result1 []*registry.Bundle, result2 error) {
	fake.listRegistryBundlesMutex.Lock()
	defer fake.listRegistryBundlesMutex.Unlock()
	fake.ListRegistryBundlesStub = nil
	fake.listRegistryBundlesReturns = struct {
		result1 []*registry.Bundle
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) ListRegistryBundlesReturnsOnCall(i int, result1 []*registry.Bundle, result2 error) {
	fake.listRegistryBundlesMutex.Lock()
	defer fake.listRegistryBundlesMutex.Unlock()
	fake.ListRegistryBundlesStub = nil
	if fake.listRegistryBundlesReturnsOnCall == nil {
		fake.listRegistryBundlesReturnsOnCall = make(map[int]struct {
			result1 []*registry.Bundle
			result2 error
		})
	}
	fake.listRegistryBundlesReturnsOnCall[i] = struct {
		result1 []*registry.Bundle
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) ListTables(arg1 context.Context) ([]string, error) {
	fake.listTablesMutex.Lock()
	ret, specificReturn := fake.listTablesReturnsOnCall[len(fake.listTablesArgsForCall)]
	fake.listTablesArgsForCall = append(fake.listTablesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("ListTables", []interface{}{arg1})
	fake.listTablesMutex.Unlock()
	if fake.ListTablesStub != nil {
		return fake.ListTablesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listTablesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuery) ListTablesCallCount() int {
	fake.listTablesMutex.RLock()
	defer fake.listTablesMutex.RUnlock()
	return len(fake.listTablesArgsForCall)
}

func (fake *FakeQuery) ListTablesCalls(stub func(context.Context) ([]string, error)) {
	fake.listTablesMutex.Lock()
	defer fake.listTablesMutex.Unlock()
	fake.ListTablesStub = stub
}

func (fake *FakeQuery) ListTablesArgsForCall(i int) context.Context {
	fake.listTablesMutex.RLock()
	defer fake.listTablesMutex.RUnlock()
	argsForCall := fake.listTablesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQuery) ListTablesReturns(result1 []string, result2 error) {
	fake.listTablesMutex.Lock()
	defer fake.listTablesMutex.Unlock()
	fake.ListTablesStub = nil
	fake.listTablesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) ListTablesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.listTablesMutex.Lock()
	defer fake.listTablesMutex.Unlock()
	fake.ListTablesStub = nil
	if fake.listTablesReturnsOnCall == nil {
		fake.listTablesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listTablesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeQuery) SendBundles(arg1 context.Context, arg2 registry.BundleSender) error {
	fake.sendBundlesMutex.Lock()
	ret, specificReturn := fake.sendBundlesReturnsOnCall[len(fake.sendBundlesArgsForCall)]
	fake.sendBundlesArgsForCall = append(fake.sendBundlesArgsForCall, struct {
		arg1 context.Context
		arg2 registry.BundleSender
	}{arg1, arg2})
	fake.recordInvocation("SendBundles", []interface{}{arg1, arg2})
	fake.sendBundlesMutex.Unlock()
	if fake.SendBundlesStub != nil {
		return fake.SendBundlesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sendBundlesReturns
	return fakeReturns.result1
}

func (fake *FakeQuery) SendBundlesCallCount() int {
	fake.sendBundlesMutex.RLock()
	defer fake.sendBundlesMutex.RUnlock()
	return len(fake.sendBundlesArgsForCall)
}

func (fake *FakeQuery) SendBundlesCalls(stub func(context.Context, registry.BundleSender) error) {
	fake.sendBundlesMutex.Lock()
	defer fake.sendBundlesMutex.Unlock()
	fake.SendBundlesStub = stub
}

func (fake *FakeQuery) SendBundlesArgsForCall(i int) (context.Context, registry.BundleSender) {
	fake.sendBundlesMutex.RLock()
	defer fake.sendBundlesMutex.RUnlock()
	argsForCall := fake.sendBundlesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuery) SendBundlesReturns(result1 error) {
	fake.sendBundlesMutex.Lock()
	defer fake.sendBundlesMutex.Unlock()
	fake.SendBundlesStub = nil
	fake.sendBundlesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuery) SendBundlesReturnsOnCall(i int, result1 error) {
	fake.sendBundlesMutex.Lock()
	defer fake.sendBundlesMutex.Unlock()
	fake.SendBundlesStub = nil
	if fake.sendBundlesReturnsOnCall == nil {
		fake.sendBundlesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendBundlesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuery) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getApisForEntryMutex.RLock()
	defer fake.getApisForEntryMutex.RUnlock()
	fake.getBundleMutex.RLock()
	defer fake.getBundleMutex.RUnlock()
	fake.getBundleForChannelMutex.RLock()
	defer fake.getBundleForChannelMutex.RUnlock()
	fake.getBundlePathIfExistsMutex.RLock()
	defer fake.getBundlePathIfExistsMutex.RUnlock()
	fake.getBundlePathsForPackageMutex.RLock()
	defer fake.getBundlePathsForPackageMutex.RUnlock()
	fake.getBundleThatProvidesMutex.RLock()
	defer fake.getBundleThatProvidesMutex.RUnlock()
	fake.getBundleThatReplacesMutex.RLock()
	defer fake.getBundleThatReplacesMutex.RUnlock()
	fake.getBundleVersionMutex.RLock()
	defer fake.getBundleVersionMutex.RUnlock()
	fake.getBundlesForPackageMutex.RLock()
	defer fake.getBundlesForPackageMutex.RUnlock()
	fake.getChannelEntriesFromPackageMutex.RLock()
	defer fake.getChannelEntriesFromPackageMutex.RUnlock()
	fake.getChannelEntriesThatProvideMutex.RLock()
	defer fake.getChannelEntriesThatProvideMutex.RUnlock()
	fake.getChannelEntriesThatReplaceMutex.RLock()
	defer fake.getChannelEntriesThatReplaceMutex.RUnlock()
	fake.getCurrentCSVNameForChannelMutex.RLock()
	defer fake.getCurrentCSVNameForChannelMutex.RUnlock()
	fake.getDefaultChannelForPackageMutex.RLock()
	defer fake.getDefaultChannelForPackageMutex.RUnlock()
	fake.getDefaultPackageMutex.RLock()
	defer fake.getDefaultPackageMutex.RUnlock()
	fake.getDependenciesForBundleMutex.RLock()
	defer fake.getDependenciesForBundleMutex.RUnlock()
	fake.getImagesForBundleMutex.RLock()
	defer fake.getImagesForBundleMutex.RUnlock()
	fake.getLatestChannelEntriesThatProvideMutex.RLock()
	defer fake.getLatestChannelEntriesThatProvideMutex.RUnlock()
	fake.getPackageMutex.RLock()
	defer fake.getPackageMutex.RUnlock()
	fake.listBundlesMutex.RLock()
	defer fake.listBundlesMutex.RUnlock()
	fake.listChannelsMutex.RLock()
	defer fake.listChannelsMutex.RUnlock()
	fake.listImagesMutex.RLock()
	defer fake.listImagesMutex.RUnlock()
	fake.listPackagesMutex.RLock()
	defer fake.listPackagesMutex.RUnlock()
	fake.listRegistryBundlesMutex.RLock()
	defer fake.listRegistryBundlesMutex.RUnlock()
	fake.listTablesMutex.RLock()
	defer fake.listTablesMutex.RUnlock()
	fake.sendBundlesMutex.RLock()
	defer fake.sendBundlesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeQuery) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ registry.Query = new(FakeQuery)
